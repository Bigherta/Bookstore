# Bookstore总体设计文档

## 1. 项目基本信息

* **项目名称**：Bookstore 书店管理系统
* **文档作者**：黄厚盛（Cyrene）
* **开发语言**：C++
* **运行平台**：Windows / Linux 命令行终端
* **数据持久化方式**：二进制文件实时读写

---

## 2. 程序功能概述

本系统是一个命令行交互式书店管理系统，通过解析用户输入指令，对用户、图书及日志进行管理，实现以下核心功能：

### （1）帐户系统

* 注册、登录、创建、删除帐户
* 修改密码
* 维护多层嵌套的登录栈
* 权限控制（{7}, {3}, {1}, {0}）

### （2）图书系统

* 存储并维护图书信息（ISBN、书名、作者、关键词、价格、库存）
* 图书检索（支持多种检索方式）
* 图书购买、选择、修改信息
* 图书进货（数量+总额）

### （3）日志系统

* 财务日志记录（收入/支出）
* 员工操作日志记录
* 财务查询、操作记录查询
* 生成财务报表与员工报告

### （4）数据持久化

* 使用文件存储所有帐户、图书、日志数据
* 可在程序首次运行时自动初始化 root
* 持久化不依赖内存缓存，严格遵守实时读写要求

---

## 3. 主体逻辑说明

程序运行的主流程如下：

### （1）初始化阶段

1. 打开或创建用户数据文件、图书数据文件、日志文件
2. 若用户文件不存在，则自动创建 root 帐户：

   * UserID：`root`
   * Password：`sjtu`
   * Privilege：{7}
3. 初始化登录栈

### （2）指令解析阶段

* 读取用户输入一行
* 清理多余空格
* 将输入行拆分为tokens
* 识别指令关键词
* 按照标准文法解析参数，包括合法性检验

### （3）权限检查阶段

* 根据当前登录栈顶部的用户确定权限
* 若权限不足，指令失败 → 输出 `Invalid`

### （4）指令执行阶段

* 执行图书、日志的相关操作
* 每次更改均同步写回文件

### （5）循环运行阶段

* 程序持续读取指令直到 EOF 或指令要求退出
* `quit` / `exit`：正常退出（清空登录栈）

---

## 4. 代码文件结构

```
bookstore/
├── CMakeLists.txt          # CMake构建配置
├── README.md               # 项目说明文档
├── include/                # 头文件目录
│   ├── parser.hpp         # 指令解析器
│   ├── Token.hpp          # Token类型与流
│   ├── user.hpp           # 用户管理与结构
│   ├── book.hpp           # 图书结构
│   ├── storage.hpp        # 存储模板与块状链表的声明与实现
│   └── log.hpp            # 日志系统
├── src/                    # 源文件目录
│   ├── main.cpp           # 程序入口
│   ├── parser.cpp         # 解析器实现
│   ├── user.cpp           # 用户管理实现
│   ├── book.cpp           # 图书方法实现
│   ├── log.cpp            # 日志系统实现
│   └── Token.cpp          # Token流实现
├── data/                   # 运行时数据文件（自动生成）
│   ├── userData           # 用户数据
│   ├── log                # 交易记录
│   └── *_index/*_book     # 图书索引文件
└── docs/                   # 文档目录
    ├── 需求分析文档.md     # 需求分析
    └── 总体设计文档.md     # 总体设计
    
```

## 5. 系统模块设计

系统采用分层与模块化设计，模块之间通过清晰的接口交互。

### **总体结构图**

```
开始
  ↓
初始化UserManager（首次运行自动创建root）
  ↓
while (读取一行输入)：
  ├── 解析指令
  ├── 执行指令
  │   ├── 权限校验（检查当前用户权限等级）
  │   ├── 参数合法性验证
  │   ├── 调用对应模块：
  │   │   ├── UserManager（用户操作）
  │   │   ├── storage<Tag>（图书操作）
  │   │   └── log（日志操作）
  │   └── 输出结果或"Invalid"
  ↓
遇到quit/exit指令或EOF
  ↓
退出程序

```

### **模块职责说明**

#### （1）Main 模块

* 负责程序主循环
* 调用 Parser 对指令进行解析
* 进行权限检查并调度其他模块

#### （2）User 模块

* 用户结构体：UserID、Password、Privilege、Username
* 登录栈维护
* 注册、登录、删除、修改密码等操作

#### （3）Book 模块

* 定义图书信息结构：ISBN、BookName、Author、Keyword、Price、Stock
* 提供检索、选择、修改、购买、进货接口
* 负责图书索引结构与块状链表存储

#### （4）Log 模块

* 财务日志（收入、支出记录）
* 员工操作日志
* 提供查询、报表、记录生成

#### （5）Storage 模块

* 进行二进制文件读写
* 提供通用模板接口存储结构体
* 支持随机读写定位

### 功能结构图

```
Main Program (main.cpp)
├── Parser Module (指令解析)
│   ├── Tokenizer (词法分析)
│   └── Executor (语义执行)
├── User Module (用户管理)
│   ├── Authentication (登录认证)
│   ├── Permission Control (权限控制)
│   ├── Account Management (账户管理)
│   └── Log Stack (登录栈)
├── Book Module (图书管理)
│   ├── Storage Engine (存储引擎)
│   │   ├── Blocked Linked List (块状链表)
│   │   ├── ISBN Index (ISBN索引)
│   │   ├── Name Index (书名索引)
│   │   ├── Author Index (作者索引)
│   │   └── Keyword Index (关键词索引)
│   └── Book Operations (图书操作)
│      ├── Search (检索)
│      ├── Buy (购买)
│      ├── Modify (修改)
│      └── Import (进货)
└── Log Module (日志系统)
    ├── Financial Logging (财务日志)
    ├── Transaction Recording (交易记录)
    └── Report Generation (报表生成)
```
---

## 6. 数据库设计

### **（1）用户数据结构**

- 存储结构：`MemoryRiver<user>`
  
- 文件格式：
  
```

[信息头: 2个int]   // 预留系统信息
[user结构体1]      // 固定大小sizeof(user)
[user结构体2]
...

```

- 储存数据说明

```

| 字段           | 类型      | 存储方式 | 说明                |
| -------------- | ------   | -------- | -------------------|
| userID         | char[31] | 文件存储 | 用户 ID（唯一）     |
| username       | char[31] | 文件存储 | 用户昵称            |
| password       | char[31] | 文件存储 | 密码                |
| privilegeLevel | int      | 文件存储 | 权限等级（0/1/3/7） |
| is_valid       | bool     | 文件存储 | 帐户是否有效        |

```

### **（2）图书数据结构** （包含块状链表与索引）

- 索引说明：本项目采用四组文件对实现多维索引：
  
```

|索引类型	 |索引文件	    |数据文件       |
|ISBN	 |isbn_index	    |isbn_book     |
|书名	 |name_index	    |name_book	|
|作者	 |author_index	    |author_book   |	
|关键词 	 |keyword_index	    |keyword_book	|

```

- 索引文件结构：

```

[信息头: 2个int]   // 预留系统信息
[index_to_head结构体1]
[index_to_head结构体2]
...

```

- 数据文件结构:
  
```

[信息头: 2个int]   // 预留系统信息
[Block结构体1]
[Block结构体2]
...

```

- Block结构：256个Book组成的块，支持链式连接
  
- 储存数据说明

```

| 字段       | 类型     | 存储方式   | 说明           |
| ---------- | -------- | ---------- | -------------- |
| ISBN       | char[20] | 二进制文件 | 图书唯一编号   |
| BookName   | char[60] | 二进制文件 | 书名           |
| Author     | char[60] | 二进制文件 | 作者           |
| Keyword    | char[60] | 二进制文件 | 多关键词       |
| Price      | double   | 二进制文件 | 图书单价       |
| Stock      | int      | 二进制文件 | 库存           |
| next_block | int      | 二进制文件 | 链表索引       |
| size       | int      | 二进制文件 | 当前块图书数量 |

```

### **（3）日志数据结构**

文件名：`log`

- 存储结构体：

```cpp
struct record {
    int count;
    double income;
    double expense;
};

```

- 存储结构：`MemoryRiver<record>`

- 文件格式：
  
```

[预留信息: int]   // 预留字段
[交易总数: int]   // 记录总交易笔数
[record结构体1]   // 交易记录
[record结构体2]
...

```


| 字段    | 类型   | 存储       | 说明         |
| ------- | ------ | ---------- | ------------|
| count   | int    | 二进制文件 | 当前交易序号 |
| income  | double | 二进制文件 | 本次收入     |
| expense | double | 二进制文件 | 本次支出     |

---

## 7.类与结构体设计

### (1)Token.hpp

- 设计目的：将原始文本与标识符绑定，以便识别指令关键词

```

// Token类型枚举
enum TokenType { LOGIN, LOGOUT, ..., TEXT, BLANK };

// Token结构体
struct Token {
    TokenType type;   // 类型标识
    std::string text; // 原始文本
    int column;       // 位置信息
};

// Token流管理
class TokenStream {
    // 支持peek、get、push等流操作
};

```

### (2)parser.hpp

- 设计目的：将一行指令以单词为单位分成若干Tokens，以便后续处理

```

class Parser
{
public:
    TokenStream tokenize(const std::string &line) const; // 将一行源码进行语义分解
    TokenType matchkeyword(const std::string &text) const; // 将字符串匹配成对应的枚举类
    static bool isLetterChar(char ch) noexcept; // 判断是否是字母
    static bool isNumberChar(char ch) noexcept; // 判断是否是数字
    static bool isN(std::string) noexcept; // 判断是否是整数
    static bool isD(std::string) noexcept; // 判断是否是小数
    void execute(const std::string&, UserManager &, log &); // 执行命令
};

```

### (3)user.hpp

- user类设计

```

class user
{
public:
    char userID[31]; //ID
    char username[31]; //昵称
    char password[31]; //密码
    int privilegeLevel = 0; // 0: visitor, 1: customer, 3: worker, 7: manager
    bool is_valid = true; // 是否合法，初始值为真

    user() {}

    user(const std::string &userID_, const std::string &username_, const std::string &password_,
         int privilegeLevel_ = 0) : privilegeLevel(privilegeLevel_)
    {
        std::strncpy(userID, userID_.c_str(), userID_.size());
        userID[userID_.size()] = '\0';
        std::strncpy(username, username_.c_str(), username_.size());
        username[username_.size()] = '\0';
        std::strncpy(password, password_.c_str(), password_.size());
        password[password_.size()] = '\0';
    }
};

```

- userManager类设计

```

class UserManager
{
public:
    // 构造函数，初始化 UserManager 对象
    UserManager();

    // 获取登录/操作记录栈的引用
    // logstack 存储每次操作的用户ID和操作描述
    auto &get_stack() { return logstack; }

    // 统计指定 userID 在数据库中出现的次数
    // 通常用于判断用户是否存在
    int count(const std::string &userID_);

    // 检查指定用户是否已经登录
    bool is_log(const std::string &);

    // 用户登录操作
    // 如果 userID 和密码匹配，则登录成功，并更新 currentUser
    bool login(const std::string &userID_, const std::string &password_);

    // 用户登出操作
    // 清除 currentUser 的登录状态
    bool logout();

    // 用户注册操作
    // 注册一个新用户，提供 userID、密码和用户名
    bool registerUser(const std::string &userID_, const std::string &password_, const std::string &username_);

    // 修改密码操作
    // 仅当当前密码匹配时才能修改
    bool passwd(const std::string &userID_, const std::string &cur_Password_, const std::string &new_Password_);

    // 添加新用户（管理员操作）
    // 可以设置用户ID、密码、权限等级和用户名
    bool useradd(const std::string &userID_, const std::string &password_, int privilegeLevel_,
                 const std::string &username_);

    // 删除用户（管理员操作）
    // 根据 userID 删除指定用户
    bool deleteUser(const std::string &userID_);

    // 获取当前登录的用户信息
    user &getCurrentUser();

    // 获取当前选中的书籍的 ISBN（或标识符）
    std::string &getSelectedbook();

    // 检查是否可以获取选中书籍（登录栈是否为空）
    bool is_valid_to_getSelectedbook();

    // 退出系统，清空登录栈
    void exit();

private:
    // 用户数据库，使用模板类 MemoryRiver 存储 user 对象
    MemoryRiver<user> userDatabase;

    // 用户操作记录栈
    // 每条记录是 <userID, 操作描述> 的 pair
    std::vector<std::pair<std::string, std::string>> logstack;

    // 当前登录的用户
    user currentUser;
};

```

### (4)book.hpp

- book类设计

```

class Book
{
private:
    char book_name[60]{};   // 书名
    char author[60]{};      // 作者
    char keywords[60]{};    // 关键词，用 '|' 分隔
    char isbn[20]{};        // ISBN 编号
    double price = 0;       // 价格
    int stock = 0;          // 库存数量

public:
    // Getter 方法
    std::string get_book_name();          // 获取书名
    std::string get_author();             // 获取作者
    std::string get_isbn();               // 获取 ISBN
    std::vector<std::string> get_keyword(); // 获取关键词列表
    double get_price();                   // 获取价格
    int get_stock();                      // 获取库存

    // Setter 方法
    void set_book_name(const std::string &); // 设置书名
    void set_author(const std::string &);    // 设置作者
    void set_keywords(const std::string &);  // 设置关键词
    void set_isbn(const std::string &);      // 设置 ISBN
    void set_price(double);                  // 设置价格
    void set_stock(int);                     // 设置库存

    // 构造函数
    Book();                        // 默认构造
    Book(std::string);             // 用 ISBN 或书名构造
    Book(const Book &other);       // 拷贝构造

    // 静态方法
    static bool is_keyword_repeated(const std::string &keyword); // 检查关键词是否重复

    // 重载运算符
    bool operator<(const Book &other) const { return strcmp(this->isbn, other.isbn) < 0; } // ISBN 小于比较
    bool operator==(const Book &other) const { return strcmp(this->isbn, other.isbn) == 0; } // ISBN 相等比较

    // 输出书籍信息
    friend std::ostream &operator<<(std::ostream &os, const Book &other)
    {
        std::string isbn_ = other.isbn;
        std::string name_ = other.book_name;
        std::string author_ = other.author;
        std::string keyword_ = other.keywords;
        os << isbn_ << '\t' << name_ << '\t' << author_ << '\t' << keyword_ << '\t';
        os << std::fixed << std::setprecision(2) << other.price << '\t';
        os << other.stock << '\n';
        return os;
    }
};

```

### (5)log.hpp

- log类设计

```

class log
{
private:
    struct record
    {
        int count;
        double income = 0;
        double expense = 0;
    };
    record cur_;

    MemoryRiver<record> log_record;

public:
    
    // 查询最后count_笔交易总额
    bool ShowFinance(int count_ = -1);

    // 记录交易
    void add_trading(double income, double expense);

    // 生成财务报表
    void ReportFinance();

    // 生成员工操作报表
    void ReportEmployee();

    // 显示操作日志
    void Log();

    // 记录用户操作
    void add_operation(int privilege, std::string name, TokenType type);

    // 格式化操作信息
    void change_opt(int privilege, std::string name, std::string info, operate &opt);
};

```

### (6)storage.hpp

- MemoryRiver类设计

```

template<class T, int info_len = 2>
class MemoryRiver
{
private:
    fstream file;       // 文件流，用于二进制读写
    string file_name;   // 文件名
    int sizeofT = sizeof(T); // 对象大小

public:
    MemoryRiver() = default; // 默认构造
    MemoryRiver(const string &file_name) : file_name(file_name) {} // 指定文件名构造
    ~MemoryRiver()           // 析构，关闭文件
    {
        if (file.is_open())
            file.close();
    }

    // 初始化文件，如果不存在则创建并写入 info_len 个 int 默认值 0
    void initialise(string FN = "");

    // 读取文件开头第 n 个 int 信息，1-based
    void get_info(int &tmp, int n);

    // 写入第 n 个 int 信息，1-based
    void write_info(int tmp, int n);

    // 将对象写入文件末尾，返回写入位置（字节偏移）
    int write(T &t);

    // 更新指定偏移位置的对象
    void update(T &t, const int index);

    // 从指定偏移位置读取对象，返回是否成功
    bool read(T &t, const int index);

    // 返回文件末尾偏移（字节数）
    int end();
};

```

- index_to_head类设计
  
```
struct index_to_head //存储索引到头块的信息
{
    char name[61]{}; //索引名称
    int head = 0; //头块位置
    index_to_head() {}
    index_to_head(std::string s)
    {
        std::memset(name, 0, sizeof(name));
        std::strncpy(name, s.c_str(), sizeof(name) - 1); //设置索引名称
    }
};

```

- storage<Tag> 模板类设计

```
template<typename Tag> //每个Tag代表不同的索引类型
class storage
{
private:
    struct Block
    {
        int next_block;  // 下一个块索引，-1表示无
        int size;        // 当前块中存储的书数量
        Book val[256]{}; // 存储书籍
        Block() : next_block(-1), size(0) {}
    };

    std::string index_name;                           // 当前索引名称
    std::vector<std::pair<std::string, int>> index_pos_pair_; // 存储索引和文件偏移
    MemoryRiver<index_to_head> file; // 记录书名到头块位置映射
    MemoryRiver<Block> book;         // 记录书籍信息块

public:
    storage() { init(); }                   // 默认构造，初始化存储
    storage(std::string s) : index_name(s) { init(); } // 带索引名称构造并初始化

    void init();              // 初始化索引和书籍存储，从文件中加载现有索引

    void Insert(Book value);   // 插入书籍，维护块链和索引

    bool Find(const std::string &isbn);    // 查找书籍是否存在

    Book Copy(const std::string &isbn);    // 根据 ISBN 返回书籍的副本

    void Show();                            // 输出当前索引下的所有书籍

    void SearchIsbn(const std::string &isbn); // 输出指定 ISBN 的书籍信息

    void Delete(Book value);               // 删除指定书籍，处理块合并

    void split(Block &block, Book val, int pos, int offset); // 分裂满块，插入新书

    void merge(Block &block, int offset); // 合并相邻块

    bool insert_book(Block &temp, Book value, int block_index); // 在块中插入书籍，处理溢出

    bool delete_book(Block &temp, Book value, int block_index); // 在块中删除书籍

    static bool modify_book(std::string isbn_, std::string name_, std::string author_,
                            std::string keywords_, std::string price_, std::string selected_book);
    // 修改书籍信息，更新索引和存储

    bool buy_book(const std::string &book_isbn, int num, double &total_cost); 
    // 购买书籍，更新库存并返回总价

    bool select_book(const std::string &book_isbn); // 选中某本书籍（用于操作）

    void import_book(const std::string &book_isbn, int num); // 增加书籍库存

    void change_stock(const std::string &book_isbn, int num); // 修改书籍库存数量
};

```

## 8.补充说明

- 当前不支持Unicode字符（仅ASCII可打印字符）

- 不支持事务回滚（操作原子性）

- 不支持并发访问（单线程）

- 不支持网络通信（本地命令行）

文档更新时间：2025年12月16日